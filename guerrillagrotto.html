<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover"
  />
  <title>guerrilla grotto</title>
  <link rel="icon" type="image/png" href="guerrillagrottowine.png" />

  <style>
    /* Reset + base */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body {
      background: #000;
      color: #fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      display: grid;
      place-items: center;
      overflow: hidden; /* no scrolling */
    }

    /* Layout */
    .wrap {
      text-align: center;
      line-height: 1.35;
      user-select: none;
      padding: 4vh 5vw;
      width: min(900px, 100%);
    }

    /* Code-like lines */
    .code-line {
      display: inline-flex;
      align-items: baseline;
      gap: .5ch;
      font-size: clamp(18px, 7vw, 48px);
      text-transform: lowercase;
      letter-spacing: .02em;
      cursor: pointer;
      transition: color .15s ease;
      white-space: nowrap;
    }
    .code-line + .code-line { margin-top: 3vh; }

    .code-line .tag { color: #8b8b8b; }       /* angle bracket “code” vibe */
    .code-line .name { color: currentColor; } /* the part that changes */
    .code-line:hover { color: #ff2b2b; }      /* hover => red */

    /* Subtle focus outline for accessibility (keyboard users) */
    .code-line:focus-visible {
      outline: 2px dashed #ff2b2b;
      outline-offset: .25rem;
    }

    /* Fullscreen glitch layer for WIN */
    .glitch-screen {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: #000;
      opacity: 0;
      mix-blend-mode: normal;
    }

    @keyframes crtShake {
      0%   { transform: translate(0,0)    skewX(0deg);         }
      20%  { transform: translate(3px,-2px) skewX(2deg);       }
      40%  { transform: translate(-3px,2px) skewX(-2deg);      }
      60%  { transform: translate(2px,3px)  skewX(1deg);       }
      80%  { transform: translate(-2px,-3px) skewX(-1deg);     }
      100% { transform: translate(0,0)    skewX(0deg);         }
    }

    @keyframes scanline {
      0%   { background-position: 0 -100vh; }
      100% { background-position: 0 100vh;  }
    }

    .glitch-on {
      opacity: 1 !important;
      animation: crtShake 160ms steps(2, end) 6,
                 scanline 480ms linear 1;
      background-image:
        repeating-linear-gradient(
          to bottom,
          rgba(255,255,255,.04) 0 2px,
          rgba(0,0,0,0) 2px 4px
        );
    }

    /* Mobile tweaks: keep things tidy on very small screens */
    @media (max-width: 380px) {
      .code-line { font-size: clamp(16px, 8vw, 22px); }
    }
  </style>
</head>

<body>
  <div class="wrap" aria-live="polite">
    <!-- make something -->
    <span class="code-line" id="make" role="button" tabindex="0" aria-label="make something">
      <span class="tag">&lt;button&gt;</span>
      <span class="name">make something</span>
      <span class="tag">&lt;/button&gt;</span>
    </span>

    <!-- submit something -->
    <span class="code-line" id="submit" role="button" tabindex="0" aria-label="submit something">
      <span class="tag">&lt;button&gt;</span>
      <span class="name">submit something</span>
      <span class="tag">&lt;/button&gt;</span>
    </span>

    <!-- win something -->
    <span class="code-line" id="win" role="button" tabindex="0" aria-label="win something">
      <span class="tag">&lt;button&gt;</span>
      <span class="name">win something</span>
      <span class="tag">&lt;/button&gt;</span>
    </span>
  </div>

  <!-- fullscreen glitch overlay -->
  <div class="glitch-screen" id="glitch"></div>

  <script>
    /* Utility: text scramble/glitch to target phrase */
    class Scrambler {
      constructor(el) {
        this.el = el;
        this.chars = "!<>-_\\/[]{}—=+*^?#________abcdefghijklmnopqrstuvwxyz";
        this.frameRequest = null;
        this.queue = [];
        this.frame = 0;
      }
      setText(newText) {
        const oldText = this.el.textContent;
        const length = Math.max(oldText.length, newText.length);
        this.queue = [];
        for (let i = 0; i < length; i++) {
          const from = oldText[i] || "";
          const to = newText[i] || "";
          const start = Math.floor(Math.random() * 8);
          const end = start + Math.floor(Math.random() * 8) + 6;
          this.queue.push({ from, to, start, end, char: "" });
        }
        cancelAnimationFrame(this.frameRequest);
        this.frame = 0;
        return new Promise(resolve => {
          const update = () => {
            let output = "";
            let complete = 0;
            for (let i = 0, n = this.queue.length; i < n; i++) {
              let { from, to, start, end, char } = this.queue[i];
              if (this.frame >= end) {
                complete++;
                output += to;
              } else if (this.frame >= start) {
                if (!char || Math.random() < 0.28) {
                  char = this.randomChar();
                  this.queue[i].char = char;
                }
                output += char;
              } else {
                output += from;
              }
            }
            this.el.textContent = output;
            if (complete === this.queue.length) {
              resolve();
            } else {
              this.frame++;
              this.frameRequest = requestAnimationFrame(update);
            }
          };
          update();
        });
      }
      randomChar() {
        return this.chars[Math.floor(Math.random() * this.chars.length)];
      }
    }

    // MAKE: toggle “something” <-> “anything” on click with scramble
    (function setupMake() {
      const line = document.querySelector('#make .name');
      const scrambler = new Scrambler(line);
      let toAnything = true;
      const toggle = () => {
        const next = toAnything ? 'make anything' : 'make something';
        toAnything = !toAnything;
        scrambler.setText(next);
      };
      document.getElementById('make').addEventListener('click', toggle);
      document.getElementById('make').addEventListener('keydown', e => {
        if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggle(); }
      });
    })();

    // SUBMIT: hover red (handled in CSS) + open draft email (mailto)
    (function setupSubmit() {
      const el = document.getElementById('submit');
      const go = () => {
        const email = 'guerrillagrotto@gmail.com'; // corrected address
        const subject = encodeURIComponent('submission');
        const body = encodeURIComponent('accepted file types: mp3, mp4, png');
        window.location.href = `mailto:${email}?subject=${subject}&body=${body}`;
      };
      el.addEventListener('click', go);
      el.addEventListener('keydown', e => {
        if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); go(); }
      });
    })();

    // WIN: hover red + screen glitches, flash white then black, then attempt to close
    (function setupWin() {
      const el = document.getElementById('win');
      const overlay = document.getElementById('glitch');

      function flashSequence() {
        // Step 1: overlay glitch
        overlay.classList.add('glitch-on');

        // Step 2: white flash -> black flash
        setTimeout(() => {
          document.body.style.transition = 'background-color 80ms linear';
          document.body.style.backgroundColor = '#fff';
          setTimeout(() => {
            document.body.style.backgroundColor = '#000';
            overlay.classList.remove('glitch-on');

            // Step 3: try to close (may be blocked if not user-opened)
            setTimeout(() => {
              window.close();
            }, 140);
          }, 140);
        }, 520);
      }

      el.addEventListener('click', flashSequence);
      el.addEventListener('keydown', e => {
        if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); flashSequence(); }
      });
    })();
  </script>
</body>
</html>

