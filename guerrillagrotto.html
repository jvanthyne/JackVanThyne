<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>guerrilla grotto</title>
  <link rel="icon" type="image/png" href="guerrillagrottowine.png" />
  <style>
    /* base */
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{
      background:#000;color:#e6e6e6;
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      display:grid;place-items:center;overflow:hidden;
    }
    .wrap{width:min(1000px,92vw);padding:4vh 4vw;text-align:left}
    .code-line{
      font-size:clamp(10px,2.4vw,18px);
      line-height:1.5;
      white-space:nowrap;
      user-select:none;
    }
    .code-line + .code-line{margin-top:2.6vh}

    /* "syntax highlighting" */
    .kw{color:#7aa2f7}          /* const, return */
    .fn{color:#c0caf5}          /* function name */
    .str{color:#9ece6a}         /* "strings" */
    .op{color:#6b7280}          /* operators , + => { } ( ) ; */
    .id{color:#e5e7eb}          /* identifiers/vars */
    .cm{color:#6b7280}          /* comments */

    /* interactive ONLY on the word "something" */
    .something{
      color:#e5e7eb;
      cursor:pointer;
      transition:color .12s ease, text-shadow .12s ease;
      outline:none;
    }
    .something:hover{color:#ff2b2b;text-shadow:0 0 6px rgba(255,43,43,.45)}
    .something:focus-visible{outline:2px dashed #ff2b2b;outline-offset:2px}

    /* full-screen flashes + glitch overlay */
    .flash{
      position:fixed;inset:0;background:#fff;opacity:0;pointer-events:none;
      transition:opacity 90ms linear;
    }
    .flash.on{opacity:1}
  </style>
</head>
<body>
  <div class="wrap" aria-live="polite">
    <!-- const make = () => { return "make " + something; } -->
    <div class="code-line" id="line-make" data-glitchable="true">
      <span class="kw">const</span> <span class="id">make</span> <span class="op">=</span> <span class="op">()</span> <span class="op">=&gt;</span> <span class="op">{</span>
      <span class="kw">return</span> <span class="str">"make "</span> <span class="op">+</span>
      <span id="make-something" class="something" role="button" tabindex="0">something</span><span class="op">;</span>
      <span class="op">}</span>
    </div>

    <!-- const submit = () => { return "submit " + something; } -->
    <div class="code-line" id="line-submit" data-glitchable="true">
      <span class="kw">const</span> <span class="id">submit</span> <span class="op">=</span> <span class="op">()</span> <span class="op">=&gt;</span> <span class="op">{</span>
      <span class="kw">return</span> <span class="str">"submit "</span> <span class="op">+</span>
      <span id="submit-something" class="something" role="button" tabindex="0">something</span><span class="op">;</span>
      <span class="op">}</span>
    </div>

    <!-- const win = () => { return "win " + something; } -->
    <div class="code-line" id="line-win" data-glitchable="true">
      <span class="kw">const</span> <span class="id">win</span> <span class="op">=</span> <span class="op">()</span> <span class="op">=&gt;</span> <span class="op">{</span>
      <span class="kw">return</span> <span class="str">"win "</span> <span class="op">+</span>
      <span id="win-something" class="something" role="button" tabindex="0">something</span><span class="op">;</span>
      <span class="op">}</span>
    </div>

    <!-- // accepted files: mp3, mp4, png -->
    <div class="code-line cm" data-glitchable="true">// accepted files: mp3, mp4, png</div>
  </div>

  <div class="flash" id="flash"></div>

  <script>
    /* letter-by-letter scrambler */
    class Scrambler {
      constructor(el, charset='!<>-_\\/[]{}—=+*^?#abcdefghijklmnopqrstuvwxyz0123456789'){
        this.el = el; this.charset = charset; this.frame = 0; this.req = null; this.queue = [];
      }
      to(text) {
        const from = this.el.textContent;
        const len = Math.max(from.length, text.length);
        this.queue = [];
        for (let i=0;i<len;i++){
          const a = from[i] || '';
          const b = text[i] || '';
          const start = Math.floor(Math.random()*6);
          const end   = start + 6 + Math.floor(Math.random()*6);
          this.queue.push({a,b,start,end,ch:''});
        }
        cancelAnimationFrame(this.req); this.frame=0;
        return new Promise(res=>{
          const step = ()=>{
            let out='', done=0;
            for (let i=0;i<this.queue.length;i++){
              let q=this.queue[i];
              if (this.frame >= q.end){ done++; out += q.b; }
              else if (this.frame >= q.start){
                if (!q.ch || Math.random()<0.3){ q.ch = this.charset[Math.floor(Math.random()*this.charset.length)]; }
                out += q.ch;
              } else out += q.a;
            }
            this.el.textContent = out;
            if (done === this.queue.length) res(); else { this.frame++; this.req=requestAnimationFrame(step); }
          };
          step();
        });
      }
    }

    /* random static-style glitch (no convergence) for an element */
    function glitchNoise(el, duration=400){
      const original = el.textContent;
      const chars = '!<>-_\\/[]{}—=+*^?#abcdefghijklmnopqrstuvwxyz0123456789';
      let t = 0;
      const tick = ()=>{
        const len = original.length;
        let out = '';
        for (let i=0;i<len;i++){
          out += Math.random()<0.5 ? original[i] : chars[Math.floor(Math.random()*chars.length)];
        }
        el.textContent = out;
        t += 30;
        if (t < duration) setTimeout(tick, 30);
        else el.textContent = original; // restore (will soon flash/close on WIN)
      };
      tick();
    }

    /* MAKE: toggle something <-> anything on the word only */
    (function(){
      const tgt = document.getElementById('make-something');
      const scr = new Scrambler(tgt);
      let any = false;
      const toggle = ()=>{ any=!any; scr.to(any?'anything':'something'); };
      tgt.addEventListener('click', toggle);
      tgt.addEventListener('keydown', e=>{ if(e.key==='Enter'||e.key===' '){e.preventDefault();toggle();} });
    })();

    /* SUBMIT: open a draft email (mailto), hover/click only on "something" */
    (function(){
      const tgt = document.getElementById('submit-something');
      const draft = ()=>{
        const email='guerrillagrotto@gmail.com';        /* corrected address */
        const subject=encodeURIComponent('submission');
        const body=encodeURIComponent('accepted file types: mp3, mp4, png');
        window.location.href=`mailto:${email}?subject=${subject}&body=${body}`;
      };
      tgt.addEventListener('click', draft);
      tgt.addEventListener('keydown', e=>{ if(e.key==='Enter'||e.key===' '){e.preventDefault();draft();} });
    })();

    /* WIN: clicking the word "something" glitches ALL text, white flash -> black -> close */
    (function(){
      const winWord = document.getElementById('win-something');
      const flash = document.getElementById('flash');

      function glitchAllThenExit(){
        // 1) glitch all visible code lines
        const lines = Array.from(document.querySelectorAll('[data-glitchable="true"]'));
        lines.forEach(el => glitchNoise(el, 600));

        // 2) after a beat, white flash
        setTimeout(()=>{
          flash.classList.add('on');                       // white
          // 3) snap to black
          setTimeout(()=>{
            flash.classList.remove('on');                  // remove white
            document.body.style.background='#000';         // ensure black
            // 4) attempt to close
            setTimeout(()=>{ window.close(); }, 160);
          }, 140);
        }, 620);
      }

      winWord.addEventListener('click', glitchAllThenExit);
      winWord.addEventListener('keydown', e=>{ if(e.key==='Enter'||e.key===' '){e.preventDefault();glitchAllThenExit();} });
    })();
  </script>
</body>
</html>
