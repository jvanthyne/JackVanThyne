<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>&lt; &gt; room 001</title>
  <style>
    :root { --bg:#fff; }

    html, body {
      margin:0; height:100%; overflow:hidden; background:var(--bg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }

    /* Optional custom cursor (triangle that inverts behind it) */
    * { cursor:none !important; }
    #custom-cursor{
      position:fixed; top:0; left:0; width:32px; height:32px; pointer-events:none; z-index:9999;
      clip-path:polygon(50% 0%, 0% 100%, 100% 100%);
      background:#000; mix-blend-mode:difference;
      transform: translate(-100px, -100px);
    }

    /* Stage is 200vw so it’s “double wide” */
    .stage {
      position:relative; width:200vw; height:100vh;
      /* moved by transform when you press arrow keys */
      will-change: transform;
      transition: transform 0.18s ease-out;
    }

    /* Two image layers stretched to exactly match the stage size */
    .layer {
      position:absolute; inset:0;
      width:200vw; height:100vh;
      object-fit: fill;          /* ensures pixel-aligned stretching to 200vw x 100vh */
    }
    .art-background { z-index:1; }
    .art-door       { z-index:3; pointer-events:none; transition: filter 0.18s ease; }

    /* Door hover effect (same as reference: invert only) */
    .art-door.hovering { filter: invert(1); }

    /* Black flash for the transition */
    .flash {
      position:fixed; inset:0; background:#000; opacity:0; pointer-events:none; z-index:999;
      transition: opacity 0.25s ease;
    }
  </style>
</head>
<body>
  <!-- Double-wide room -->
  <div class="stage" id="stage">
    <img src="art_room001_background.png" class="layer art-background" alt="Room background">
    <img src="art_room001_door.png"        class="layer art-door" id="doorImg" alt="Door overlay">
  </div>

  <div id="flash" class="flash"></div>
  <div id="custom-cursor"></div>

  <script>
    /* ---------- Custom cursor ---------- */
    const cursor = document.getElementById('custom-cursor');
    const moveCursor = (x,y)=> cursor.style.transform = `translate(${x-16}px, ${y-16}px)`;
    document.addEventListener('mousemove', e => {
      moveCursor(e.clientX, e.clientY);
      testDoorHover(e.clientX, e.clientY);
    }, {passive:true});
    document.addEventListener('touchmove', e => {
      const t = e.touches[0]; if (!t) return;
      moveCursor(t.clientX, t.clientY);
      testDoorHover(t.clientX, t.clientY);
    }, {passive:true});

    /* ---------- Horizontal scroll with arrow keys (double wide) ---------- */
    const stage = document.getElementById('stage');
    let scrollX = 0;
    const maxScroll = () => Math.max(0, window.innerWidth); // 200vw - 100vw

    function applyScroll() {
      // move the whole 200vw stage left as you scroll
      stage.style.transform = `translateX(-${scrollX}px)`;
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowRight') {
        scrollX = Math.min(scrollX + 60, maxScroll());
        applyScroll();
      } else if (e.key === 'ArrowLeft') {
        scrollX = Math.max(scrollX - 60, 0);
        applyScroll();
      }
    });
    window.addEventListener('resize', () => {
      scrollX = Math.min(scrollX, maxScroll());
      applyScroll();
      // Nudge hover recompute after resize
      const evt = new MouseEvent('mousemove', { clientX: window.innerWidth/2, clientY: window.innerHeight/2 });
      document.dispatchEvent(evt);
    });

    /* ---------- Pixel-precise door hover & click (reference behavior) ---------- */
    const doorImg = document.getElementById('doorImg');

    // Offscreen canvas for hit-testing the door’s opaque pixels
    const doorHitCanvas = document.createElement('canvas');
    const doorHitCtx = doorHitCanvas.getContext('2d', { willReadFrequently:true });
    let doorReady = false;

    function prepareDoorHitmap() {
      const w = doorImg.naturalWidth  || doorImg.width;
      const h = doorImg.naturalHeight || doorImg.height;
      if (!w || !h) return;
      doorHitCanvas.width = w;
      doorHitCanvas.height = h;
      doorHitCtx.clearRect(0,0,w,h);

      const bmp = new Image();
      bmp.crossOrigin = doorImg.crossOrigin || '';
      bmp.src = doorImg.currentSrc || doorImg.src;
      bmp.onload = () => { doorHitCtx.drawImage(bmp, 0, 0); doorReady = true; };
      if (bmp.complete && bmp.naturalWidth) { doorHitCtx.drawImage(bmp, 0, 0); doorReady = true; }
    }
    if (doorImg.complete && doorImg.naturalWidth) prepareDoorHitmap();
    else doorImg.addEventListener('load', prepareDoorHitmap, { once:true });

    function testDoorHover(clientX, clientY){
      if (!doorReady) { doorImg.classList.remove('hovering'); return; }
      // Because the door image is stretched to the full stage (200vw x 100vh)
      // and the stage is transformed, getBoundingClientRect() yields the
      // on-screen rect we can map against directly.
      const rect = doorImg.getBoundingClientRect();
      if (clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom) {
        doorImg.classList.remove('hovering'); return;
      }
      const xNorm = (clientX - rect.left) / rect.width;   // 0..1 across the 200vw image
      const yNorm = (clientY - rect.top)  / rect.height;  // 0..1 across the 100vh image
      const px = Math.floor(xNorm * doorHitCanvas.width);
      const py = Math.floor(yNorm * doorHitCanvas.height);
      if (px < 0 || py < 0 || px >= doorHitCanvas.width || py >= doorHitCanvas.height) {
        doorImg.classList.remove('hovering'); return;
      }
      const alpha = doorHitCtx.getImageData(px, py, 1, 1).data[3]; // 0..255
      if (alpha > 1) doorImg.classList.add('hovering'); else doorImg.classList.remove('hovering');
    }

    function tryEnter(clientX, clientY){
      if (!doorReady) return;
      const rect = doorImg.getBoundingClientRect();
      const inside = (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom);
      if (inside && doorImg.classList.contains('hovering')) {
        // Flash, then go to art.html (as requested)
        const flash = document.getElementById('flash');
        flash.style.opacity = 1;
        setTimeout(()=>{ window.location.href = 'art.html'; }, 250);
      }
    }
    document.addEventListener('click', (e) => tryEnter(e.clientX, e.clientY));
    document.addEventListener('touchend', (e) => {
      const t = e.changedTouches[0]; if (t) tryEnter(t.clientX, t.clientY);
    });

    // Reset hover state on page restore
    window.addEventListener('pageshow', () => {
      doorImg.classList.remove('hovering');
      const evt = new MouseEvent('mousemove', { clientX: window.innerWidth/2, clientY: window.innerHeight/2 });
      document.dispatchEvent(evt);
    });
  </script>
</body>
</html>
